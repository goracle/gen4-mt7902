============================================================
PATCH 3 of 4 â€” os/linux/gl_init.c

Replace the entire mt79xx_wfsys_cold_boot_and_wait function
(from "int32_t mt79xx_wfsys_cold_boot_and_wait" through the
closing "}" that sits right before "static int32_t wlanProbe").

The replacement is a drop-in: same signature, same contract for
the two chip_info hooks.  Return-value contract is now:
   0            success
  -EINVAL       prAdapter NULL
  -ENOTSUPP     chip hooks missing
  -EIO          BAR returned 0xffffffff (bus dead)
  -ETIMEDOUT    poll loop exhausted (MCU never set init-done)
============================================================

--- a/os/linux/gl_init.c
+++ b/os/linux/gl_init.c
 int32_t mt79xx_wfsys_cold_boot_and_wait(struct ADAPTER *prAdapter)
 {
-    struct mt66xx_chip_info *prChipInfo;
-    int attempts = 2;
-    int ret = -ETIMEDOUT;
-
-    if (!prAdapter) return -EINVAL;
-    prChipInfo = prAdapter->chip_info;
-    if (!prChipInfo || !prChipInfo->asicWfsysRst || !prChipInfo->asicPollWfsysSwInitDone) {
-        DBGLOG(INIT, WARN, "WFSYS reset/poll hooks not present\n");
-        return -ENOTSUPP;
-    }
-
-    /* If it is already alive, skip everything */
-    if (prChipInfo->asicPollWfsysSwInitDone(prAdapter)) {
-      //DBGLOG(INIT, INFO, "WFSYS already initialized before reset\n");
-	DBGLOG(INIT, WARN, "WFSYS already initialized! Forcing cold boot anyway.\n");
-        //return 0;
-    }
-
-    while (attempts-- > 0) {
-      //uint32_t pre_rev = 0, post_rev = 0;
-        DBGLOG(INIT, INFO, "WFSYS cold-boot attempt %d\n", 2 - attempts);
-
-        /* Optional: read and log some CONNINFRA rev if available
-         * Replace HAL_MCR_RD/CONNINFRA_REV with the driver macro if available.
-         */
-        #ifdef CONNINFRA_INFRACON_REV_ADDR
-        HAL_MCR_RD(prAdapter, CONNINFRA_INFRACON_REV_ADDR, &pre_rev);
-        DBGLOG(INIT, INFO, "CONNINFRA rev pre-reset: 0x%08x\n", pre_rev);
-        #endif
-
-        /* Assert reset (hold MCU) */
-        prChipInfo->asicWfsysRst(prAdapter, TRUE);
-
-        /* Wait briefly for reset to take effect.
-         * Use msleep if you can sleep in this context; otherwise udelay.
-         */
-        mdelay(5); /* 5ms settle */
-
-        /* Deassert reset */
-        prChipInfo->asicWfsysRst(prAdapter, FALSE);
-
-        /* Allow MCU ROM + early boot to run. Longer wait here helps a lot. */
-        /* Poll for up to 1000 ms, checking every 10 ms */
-        {
-            int i;
-            bool ok = false;
-            for (i = 0; i < 100; i++) {
-                if (prChipInfo->asicPollWfsysSwInitDone(prAdapter)) {
-                    ok = true;
-                    break;
-                }
-                mdelay(10);
-            }
-            if (ok) {
-                DBGLOG(INIT, INFO, "WFSYS MCU signaled init-done\n");
-                #ifdef CONNINFRA_INFRACON_REV_ADDR
-                HAL_MCR_RD(prAdapter, CONNINFRA_INFRACON_REV_ADDR, &post_rev);
-                DBGLOG(INIT, INFO, "CONNINFRA rev post-reset: 0x%08x\n", post_rev);
-                #endif
-                ret = 0;
-                break;
-            } else {
-                DBGLOG(INIT, WARN, "WFSYS init timeout on attempt, dumping debug registers\n");
-                /* Call driver debug dump helpers here to capture more info */
-                /* e.g. mt7902_show_debug_sop_info(prAdapter); or pcie_mt7902_dump_conninfra_debug_cr(prAdapter); */
-                /* If a graceful full reset mechanism exists, trigger it here */
-            }
-        }
-
-        /* Short backoff before retry */
-        mdelay(50);
-    }
-
-    return ret;
-}
+    struct mt66xx_chip_info *prChipInfo;
+    struct GL_HIF_INFO      *prHifInfo;
+    void __iomem            *bar;
+    int  attempts = 2;
+    int  ret      = -ETIMEDOUT;
+
+    if (!prAdapter) return -EINVAL;
+
+    prChipInfo = prAdapter->chip_info;
+    if (!prChipInfo || !prChipInfo->asicWfsysRst ||
+        !prChipInfo->asicPollWfsysSwInitDone) {
+        DBGLOG(INIT, WARN, "WFSYS reset/poll hooks not present\n");
+        return -ENOTSUPP;
+    }
+
+    /* Grab the BAR pointer for the raw blind-check.  We do NOT use
+     * HAL_MCR_RD here because HAL_MCR_RD short-circuits on
+     * ADAPTER_FLAG_HW_ERR; if that flag is stale we would never see
+     * 0xffffffff and would burn attempts against a dead bus.
+     */
+    prHifInfo = &prAdapter->prGlueInfo->rHifInfo;
+    bar       = prHifInfo->CSRBaseAddress;
+    if (!bar) {
+        DBGLOG(INIT, ERROR, "cold_boot: CSRBaseAddress is NULL\n");
+        return -EIO;
+    }
+
+    /* Log whether WFSYS thinks it is already alive.  We force the
+     * cold boot regardless (the caller already did clock/power
+     * hammering that invalidates any prior state), but the value is
+     * useful in the log.
+     */
+    if (prChipInfo->asicPollWfsysSwInitDone(prAdapter))
+        DBGLOG(INIT, WARN, "WFSYS poll says init-done PRE-reset; forcing cold boot anyway\n");
+
+    while (attempts-- > 0) {
+        int      i;
+        bool     ok   = false;
+        uint32_t bar0 = 0;
+
+        DBGLOG(INIT, INFO, "WFSYS cold-boot attempt %d of 2\n", 2 - attempts);
+
+        /* ----------------------------------------------------------
+         * BAR blind-check: raw readl, no HAL indirection.
+         * If the bus is dead we return -EIO immediately and do NOT
+         * consume another attempt.  pcie.c maps -EIO to
+         * RECOV_FAIL_COLDBOOT_BLIND.
+         * ----------------------------------------------------------
+         */
+        bar0 = readl_relaxed(bar);
+        DBGLOG(INIT, INFO, "  BAR0[0] pre-reset = 0x%08x\n", bar0);
+        if (bar0 == 0xffffffff) {
+            DBGLOG(INIT, ERROR,
+                   "  BAR blind (0xffffffff) - bus is dead, aborting cold boot\n");
+            dump_pci_state(prHifInfo->pdev);
+            dump_mailbox(prAdapter);
+            return -EIO;
+        }
+
+        /* ----------------------------------------------------------
+         * CONNINFRA revision snapshot (pre-reset, debug only)
+         * ----------------------------------------------------------
+         */
+#ifdef CONNINFRA_INFRACON_REV_ADDR
+        {
+            uint32_t pre_rev = 0;
+            HAL_MCR_RD(prAdapter, CONNINFRA_INFRACON_REV_ADDR, &pre_rev);
+            DBGLOG(INIT, INFO, "  CONNINFRA rev pre-reset: 0x%08x\n", pre_rev);
+        }
+#endif
+
+        /* Assert reset (hold MCU) */
+        prChipInfo->asicWfsysRst(prAdapter, TRUE);
+        mdelay(5);   /* 5 ms settle for reset to propagate */
+
+        /* Deassert reset - MCU ROM starts executing */
+        prChipInfo->asicWfsysRst(prAdapter, FALSE);
+
+        /* ----------------------------------------------------------
+         * Poll for init-done: up to 1000 ms in 10 ms steps.
+         *
+         * On every iteration we also do a raw BAR read every 100 ms.
+         * If it goes 0xffffffff mid-poll the bus collapsed during
+         * boot (e.g. link retrained) - we bail immediately with -EIO
+         * rather than burning the remaining poll time.
+         *
+         * On the LAST iteration (timeout) we log the raw BAR value
+         * so the dump shows what the device was actually presenting,
+         * not just "timeout".
+         * ----------------------------------------------------------
+         */
+        for (i = 0; i < 100; i++) {
+            if (prChipInfo->asicPollWfsysSwInitDone(prAdapter)) {
+                ok = true;
+                break;
+            }
+
+            /* Periodic BAR sanity check every 10 iterations (100 ms) */
+            if ((i % 10) == 9) {
+                bar0 = readl_relaxed(bar);
+                if (bar0 == 0xffffffff) {
+                    DBGLOG(INIT, ERROR,
+                           "  BAR went blind at poll iter %d - bus collapsed\n", i);
+                    dump_pci_state(prHifInfo->pdev);
+                    dump_mailbox(prAdapter);
+                    return -EIO;
+                }
+            }
+            mdelay(10);
+        }
+
+        if (ok) {
+            DBGLOG(INIT, INFO, "  WFSYS MCU signaled init-done at iter %d\n", i);
+#ifdef CONNINFRA_INFRACON_REV_ADDR
+            {
+                uint32_t post_rev = 0;
+                HAL_MCR_RD(prAdapter, CONNINFRA_INFRACON_REV_ADDR, &post_rev);
+                DBGLOG(INIT, INFO, "  CONNINFRA rev post-reset: 0x%08x\n", post_rev);
+            }
+#endif
+            ret = 0;
+            break;   /* out of attempts loop */
+        }
+
+        /* ----------------------------------------------------------
+         * Timeout on this attempt.  Log the last raw BAR value and
+         * call the dump helpers so we get mailbox + PDMA state before
+         * we either retry or give up.
+         * ----------------------------------------------------------
+         */
+        bar0 = readl_relaxed(bar);
+        DBGLOG(INIT, WARN,
+               "  WFSYS init-done timeout (attempt %d). BAR0[0]=0x%08x\n",
+               2 - attempts, bar0);
+        dump_mailbox(prAdapter);
+        dump_pdma_state(prAdapter);
+
+        mdelay(50);  /* short backoff before retry */
+    }   /* end attempts */
+
+    /* If we fell through without ok==true, ret is still -ETIMEDOUT.
+     * pcie.c maps that to RECOV_FAIL_COLDBOOT_TIMEOUT.
+     */
+    return ret;
+}