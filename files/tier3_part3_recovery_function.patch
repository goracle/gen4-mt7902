--- a/os/linux/hif/pcie/pcie.c
+++ b/os/linux/hif/pcie/pcie.c
@@ -825,6 +825,161 @@ void glSetPowerState(IN struct GLUE_INFO *prGlueInfo, IN uint32_t ePowerMode)
 }
 
 /*----------------------------------------------------------------------------*/
+/*!
+ * \brief Tier-3 recovery: PCIe function resurrection after power loss
+ *
+ * This function handles the case where the device lost power and MMIO
+ * reads return 0xffffffff. It performs a full PCIe re-initialization
+ * followed by cold-boot MCU init, effectively treating the device as
+ * if it was hot-unplugged and replugged.
+ *
+ * This is the industry-standard approach for PCIe devices with firmware
+ * that can experience arbitrary power loss (Intel iwlwifi, AMD GPU drivers
+ * all implement similar recovery paths).
+ *
+ * \param[in] pdev       The PCI device
+ * \param[in] prGlueInfo The glue info structure
+ *
+ * \retval WLAN_STATUS_SUCCESS   Recovery successful, device resurrected
+ * \retval WLAN_STATUS_FAILURE   Recovery failed, device remains dead
+ */
+/*----------------------------------------------------------------------------*/
+static uint32_t mt79xx_pci_function_recover(struct pci_dev *pdev,
+					    struct GLUE_INFO *prGlueInfo)
+{
+	struct ADAPTER *prAdapter;
+	struct mt66xx_chip_info *prChipInfo;
+	struct REG_INFO *prRegInfo;
+	uint32_t u4Status;
+	struct GL_HIF_INFO *prHifInfo;
+
+	if (!pdev || !prGlueInfo) {
+		DBGLOG(HAL, ERROR, "Tier-3 recovery: NULL parameters\n");
+		return WLAN_STATUS_FAILURE;
+	}
+
+	prAdapter = prGlueInfo->prAdapter;
+	prHifInfo = &prGlueInfo->rHifInfo;
+	prChipInfo = prAdapter->chip_info;
+
+	/* Prevent concurrent recovery attempts */
+	if (prHifInfo->fgInPciRecovery) {
+		DBGLOG(HAL, WARN, "Tier-3 recovery already in progress\n");
+		return WLAN_STATUS_FAILURE;
+	}
+
+	prHifInfo->fgInPciRecovery = TRUE;
+	DBGLOG(HAL, WARN,
+	       "=== Tier-3 PCIe Recovery Start (MMIO power loss detected) ===\n");
+
+	/* Step 1: Stop upper layer activity */
+	DBGLOG(HAL, INFO, "Tier-3: Stopping network queues\n");
+	netif_tx_stop_all_queues(prGlueInfo->prDevHandler);
+
+	/* Step 2: Disable interrupts to prevent spurious IRQs during recovery */
+	DBGLOG(HAL, INFO, "Tier-3: Disabling interrupts\n");
+	if (prHifInfo->u4IrqId) {
+		disable_irq_nosync(prHifInfo->u4IrqId);
+	}
+
+	/* Step 3: Tear down PCIe function state */
+	/* This forces exit from D3cold and clears any stale bus state */
+	DBGLOG(HAL, WARN, "Tier-3: Tearing down PCIe function\n");
+	pci_clear_master(pdev);
+	pci_disable_device(pdev);
+
+	/* Step 4: Force device to D0 power state */
+	/* This is the critical step that pulls the device out of deep sleep */
+	DBGLOG(HAL, INFO, "Tier-3: Forcing device to D0 (exit deep sleep)\n");
+	pci_set_power_state(pdev, PCI_D0);
+	msleep(100); /* Allow power rails to stabilize */
+
+	/* Step 5: Re-enable PCIe function */
+	/* This restores config space and makes the device accessible again */
+	DBGLOG(HAL, WARN, "Tier-3: Re-enabling PCIe function\n");
+	u4Status = pci_enable_device(pdev);
+	if (u4Status != 0) {
+		DBGLOG(HAL, ERROR, "Tier-3: pci_enable_device failed: %d\n",
+		       u4Status);
+		goto recovery_failed;
+	}
+
+	/* Step 6: Restore PCI state and re-enable bus mastering */
+	DBGLOG(HAL, INFO, "Tier-3: Restoring PCI state\n");
+	pci_restore_state(pdev);
+	pci_set_master(pdev);
+
+	/* Step 7: Re-map MMIO BAR space */
+	/* The BAR virtual address may have changed, so we must remap */
+	DBGLOG(HAL, WARN, "Tier-3: Re-mapping MMIO BAR\n");
+	if (CSRBaseAddress) {
+		iounmap(CSRBaseAddress);
+		CSRBaseAddress = NULL;
+	}
+
+	CSRBaseAddress = ioremap(pci_resource_start(pdev, 0),
+				 pci_resource_len(pdev, 0));
+	if (!CSRBaseAddress) {
+		DBGLOG(HAL, ERROR, "Tier-3: ioremap failed\n");
+		goto recovery_failed;
+	}
+	DBGLOG(HAL, INFO, "Tier-3: MMIO remapped to %p\n", CSRBaseAddress);
+
+	/* Step 8: Cold boot WFSYS MCU */
+	/* This is the SAME sequence as wlanProbe() - we cannot skip this */
+	/* The MCU/WFSYS state is undefined after power loss */
+	DBGLOG(HAL, WARN, "Tier-3: Performing WFSYS MCU cold boot\n");
+	prAdapter->fgIsFwOwn = TRUE; /* Reset ownership state */
+	
+	if (mt79xx_wfsys_cold_boot_and_wait(prAdapter) != 0) {
+		DBGLOG(HAL, ERROR, "Tier-3: MCU cold boot failed\n");
+		goto recovery_failed;
+	}
+	DBGLOG(HAL, INFO, "Tier-3: MCU is alive and initialized\n");
+
+	/* Step 9: Re-initialize adapter */
+	/* Run the same init path as wlanAdapterStart() */
+	DBGLOG(HAL, WARN, "Tier-3: Re-initializing adapter\n");
+	prRegInfo = &prGlueInfo->rRegInfo;
+	
+	u4Status = wlanAdapterStart(prAdapter, prRegInfo, FALSE);
+	if (u4Status != WLAN_STATUS_SUCCESS) {
+		DBGLOG(HAL, ERROR, "Tier-3: wlanAdapterStart failed: 0x%x\n",
+		       u4Status);
+		goto recovery_failed;
+	}
+
+	/* Step 10: Re-enable interrupts */
+	DBGLOG(HAL, INFO, "Tier-3: Re-enabling interrupts\n");
+	if (prHifInfo->u4IrqId) {
+		enable_irq(prHifInfo->u4IrqId);
+	}
+
+	/* Step 11: Wake network queues and resume operation */
+	DBGLOG(HAL, INFO, "Tier-3: Waking network queues\n");
+	netif_tx_wake_all_queues(prGlueInfo->prDevHandler);
+
+	/* Clear recovery flags */
+	prHifInfo->fgInPciRecovery = FALSE;
+	prHifInfo->fgMmioGone = FALSE;
+
+	DBGLOG(HAL, WARN,
+	       "=== Tier-3 PCIe Recovery Complete (device resurrected) ===\n");
+	return WLAN_STATUS_SUCCESS;
+
+recovery_failed:
+	DBGLOG(HAL, ERROR,
+	       "=== Tier-3 PCIe Recovery FAILED - device remains dead ===\n");
+	prHifInfo->fgInPciRecovery = FALSE;
+	
+	/* Mark adapter as unresponsive to prevent further access attempts */
+	wlanSetChipNoAck(prAdapter);
+	
+	/* Note: IRQs intentionally left disabled if we reach here */
+	return WLAN_STATUS_FAILURE;
+}
+
+/*----------------------------------------------------------------------------*/
 /*!
  * \brief Initialize bus operation and hardware settings of the adapter.
  *
