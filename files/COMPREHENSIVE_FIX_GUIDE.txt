COMPREHENSIVE FIX SUMMARY: PCIe Recovery "Scheduling While Atomic" Bug
========================================================================

PROBLEM:
--------
The mt79xx_pci_function_recover() function contains many blocking/sleeping
operations (msleep, mdelay, pci_reset_function, etc.) but is being called
from atomic context (IRQ handler → tasklet → MMIO read returns 0xffffffff
→ recovery function).

This causes kernel panic: "BUG: scheduling while atomic"

ROOT CAUSE:
-----------
Call chain looks like:
  mtk_pci_interrupt (IRQ context)
    → halDisableInterrupt()
      → some function reads MMIO
        → gets 0xffffffff
          → calls mt79xx_pci_function_recover()
            → msleep() ← PANIC! Can't sleep in IRQ!

THE FIX:
--------
Implement a deferred work queue pattern:
1. Detect MMIO failure in atomic context
2. Set a flag, disable IRQs, stop network queues (all atomic-safe)
3. Schedule a workqueue job
4. Return immediately from atomic context
5. Workqueue runs in process context where sleeping is allowed
6. Full recovery happens there with all the msleep/mdelay calls


FILES TO MODIFY:
================

1. os/linux/hif/pcie/pcie.c
   - Add mt7902_mmio_dead() - fast MMIO check
   - Add mt7902_schedule_recovery_from_atomic() - scheduler
   - Add mt7902_recovery_work() - workqueue handler  
   - Modify mt79xx_pci_function_recover() - add in_atomic() check
   - Modify mtk_pci_interrupt() - add MMIO check
   - Modify glBusSetIrq() - initialize recovery infrastructure
   - Modify glBusFreeIrq() - cleanup recovery infrastructure
   
   FILE: fix-atomic-recovery.patch (already created)

2. os/linux/hif/pcie/include/hif.h (or os/linux/include/gl_os.h)
   - Add MTK_FLAG_MMIO_GONE define
   - Add fields to GL_HIF_INFO:
     * state_flags
     * recovery_work
     * recovery_lock
     * saved_irq
     * pdev (if not already present)
   
   FILE: HEADER_MODIFICATIONS.txt (instructions provided)

3. os/linux/hif/common/hal_pdma.c
   - Modify call site(s) to mt79xx_pci_function_recover()
   - Check atomic context before calling
   - Use mt7902_schedule_recovery_from_atomic() if in atomic context
   
   FILE: HAL_PDMA_MODIFICATIONS.txt (instructions provided)


APPLYING THE PATCHES:
======================

Step 1: Apply the main pcie.c patch
------------------------------------
cd /path/to/driver/source
patch -p1 < fix-atomic-recovery.patch

Step 2: Manually modify the header file
----------------------------------------
1. Find where GL_HIF_INFO is defined:
   grep -r "struct GL_HIF_INFO" include/

2. Open that header file and add the fields listed in HEADER_MODIFICATIONS.txt

Step 3: Manually modify hal_pdma.c
-----------------------------------
Follow instructions in HAL_PDMA_MODIFICATIONS.txt to fix call sites


COMPILATION:
============
make clean
make

If you get errors about undefined references or missing fields, double-check:
- Header modifications were applied correctly
- The field names match between header and implementation
- All necessary includes are present


TESTING PROCEDURE:
==================

Test 1: Normal Operation
-------------------------
1. Load driver: sudo insmod mt7902.ko
2. Check dmesg for "Recovery infrastructure initialized"
3. Connect to WiFi network
4. Transfer some data (ping, download file)
5. Verify everything works normally

Test 2: Trigger Recovery
-------------------------
1. Find your PCIe device: lspci | grep -i wireless
   (e.g., 02:00.0)
2. Trigger MMIO failure: sudo setpci -s 02:00.0 COMMAND=0x0
3. Watch dmesg in real-time: sudo dmesg -w

Expected dmesg output:
----------------------
[  123.456] wlan: MMIO dead in ISR - scheduling recovery
[  123.456] wlan: Recovery work starting (process context)
[  123.456] wlan: === Tier-3 PCIe Recovery Start (Safe Mode) ===
[  123.567] wlan: Tier-4: Killing tasklets and disabling IRQ line
[  ... recovery progress messages ...]
[  124.789] wlan: === Tier-3 PCIe Recovery Complete ===
[  124.789] wlan: === Recovery work completed successfully ===

What you should NOT see:
------------------------
[  XXX.XXX] BUG: scheduling while atomic: ...
[  XXX.XXX] Call Trace:
[  XXX.XXX]  dump_stack+...
[  XXX.XXX]  __schedule_bug+...

Test 3: Stress Test
--------------------
1. Repeat Test 2 multiple times (5-10 times)
2. Try during heavy traffic (large download)
3. Try rapid successive triggers (setpci, wait 1s, setpci again)
4. Verify no kernel panics, no deadlocks
5. Verify recovery either succeeds or fails cleanly

Test 4: Recovery Failure Path
------------------------------
If recovery fails (e.g., hardware really is dead):
1. Should see "Recovery work FAILED" in dmesg
2. Should see detailed failure reason and stage
3. Should NOT see kernel panic
4. Driver should be in known safe state (disabled)


DEBUGGING:
==========

If recovery doesn't trigger:
-----------------------------
- Check that mt7902_mmio_dead() is being called
- Add DBGLOG in interrupt handler to verify
- Check that 0xffffffff is actually being read

If still getting "scheduling while atomic":
-------------------------------------------
- Check all call paths to mt79xx_pci_function_recover()
- There might be another caller we missed
- Add more DBGLOG to trace the call stack

If recovery fails:
------------------
- Check which stage failed (u8RecoveryStage)
- Check failure reason (u8RecoveryFailReason)  
- Look at PCI config dump in dmesg
- Hardware might be genuinely unrecoverable


ROLLBACK:
=========

If you need to undo these changes:

patch -p1 -R < fix-atomic-recovery.patch

Then manually remove the header changes and hal_pdma.c changes.


ADDITIONAL NOTES:
=================

1. The MMIO check register offset (currently 0x0) might need adjustment
   based on your specific chip. Use a register that:
   - Is always mapped
   - Always returns a valid value (not 0xffffffff)
   - Is safe to read in any power state
   - Common choices: chip ID, version register, or ROM code status

2. The patch uses system workqueue (schedule_work). For better control,
   you could create a dedicated workqueue, but system workqueue is fine
   for recovery which is rare.

3. The recovery_lock mutex prevents concurrent recoveries. If you want
   to handle multiple devices, make sure each device has its own lock.

4. The state_flags uses atomic bitops which are lockless and safe from
   any context. This is critical for the ISR path.

5. If you have multiple chips (mt7902, mt7922, etc.), you might want to:
   - Make function names more generic (e.g., mtk_schedule_recovery)
   - Or create chip-specific wrappers
   - The current patch uses mt7902_ prefix for clarity


SUCCESS CRITERIA:
=================

The fix is successful if:
✓ Normal operation works (connect, transfer data)
✓ Triggering MMIO failure doesn't cause kernel panic
✓ Recovery is scheduled from atomic context
✓ Recovery runs in process context
✓ No "BUG: scheduling while atomic" messages
✓ Device either recovers or fails cleanly
✓ No system hang or freeze


CONTACT:
========

If you encounter issues or need clarification:
- Check kernel logs (dmesg) for detailed error messages
- Enable more verbose logging if needed
- The patch includes DBGLOG statements to trace execution
- Compare actual behavior against expected dmesg output above
