MODIFICATIONS FOR hal_pdma.c
============================

Based on the grep output showing:

    os/linux/hif/common/hal_pdma.c:		return (mt79xx_pci_function_recover(prAdapter->prGlueInfo->rHifInfo.pdev,

This is where mt79xx_pci_function_recover() is being called from, and this
call site is likely in atomic context (ISR/tasklet).

WHAT TO CHANGE:
===============

Find the location in hal_pdma.c where mt79xx_pci_function_recover() is called.
It probably looks something like this:

    /* BEFORE (BROKEN - causes "scheduling while atomic") */
    if (some_mmio_read == 0xffffffff) {
        return (mt79xx_pci_function_recover(
            prAdapter->prGlueInfo->rHifInfo.pdev,
            prAdapter->prGlueInfo));
    }


Change it to check the context and handle appropriately:

    /* AFTER (FIXED - safe in atomic context) */
    if (some_mmio_read == 0xffffffff) {
        /* If we're in atomic context, schedule recovery and return immediately */
        if (in_atomic() || in_interrupt()) {
            DBGLOG(HAL, WARN, 
                "MMIO failure detected in atomic context (hal_pdma)\n");
            mt7902_schedule_recovery_from_atomic(prAdapter->prGlueInfo);
            return WLAN_STATUS_PENDING;
        }
        
        /* If we're in process context, call directly */
        return mt79xx_pci_function_recover(
            prAdapter->prGlueInfo->rHifInfo.pdev,
            prAdapter->prGlueInfo);
    }


ALTERNATIVE SIMPLER FIX:
========================

If the above seems complex, you can just ALWAYS schedule the recovery work:

    /* SIMPLEST FIX - always defer to workqueue */
    if (some_mmio_read == 0xffffffff) {
        DBGLOG(HAL, WARN, "MMIO failure detected - scheduling recovery\n");
        mt7902_schedule_recovery_from_atomic(prAdapter->prGlueInfo);
        return WLAN_STATUS_PENDING;
    }

This is safer and simpler, though slightly less efficient (adds ~1ms latency
for the workqueue to run, but that's negligible compared to the 500+ms 
recovery takes anyway).


WHAT IF THERE ARE MULTIPLE CALL SITES?
=======================================

Search for all calls:
    
    grep -n "mt79xx_pci_function_recover" os/linux/hif/common/hal_pdma.c

For EACH call site, apply the same fix:
1. Check if in atomic context
2. If yes: call mt7902_schedule_recovery_from_atomic() and return PENDING
3. If no: call mt79xx_pci_function_recover() directly

Or just ALWAYS use mt7902_schedule_recovery_from_atomic() for simplicity.


DECLARING THE FUNCTION:
========================

Add this declaration at the top of hal_pdma.c (after includes):

    /* Forward declaration for atomic-safe recovery */
    extern void mt7902_schedule_recovery_from_atomic(struct GLUE_INFO *prGlueInfo);

Or add it to a header file that both pcie.c and hal_pdma.c include.


COMPLETE PATCH EXAMPLE FOR hal_pdma.c:
======================================
(You'll need to adjust line numbers based on your actual file)

diff --git a/os/linux/hif/common/hal_pdma.c b/os/linux/hif/common/hal_pdma.c
index 1234567..abcdefg 100644
--- a/os/linux/hif/common/hal_pdma.c
+++ b/os/linux/hif/common/hal_pdma.c
@@ -10,6 +10,9 @@
 
 #include "precomp.h"
 
+/* Forward declaration for atomic-safe recovery */
+extern void mt7902_schedule_recovery_from_atomic(struct GLUE_INFO *prGlueInfo);
+
 /* ... rest of file ... */
 
 @@ -XXX,X +XXX,X @@ some_function_name(...)
 {
     /* ... existing code ... */
     
-    return (mt79xx_pci_function_recover(prAdapter->prGlueInfo->rHifInfo.pdev,
-                                        prAdapter->prGlueInfo));
+    /* Check if in atomic context and schedule recovery accordingly */
+    if (in_atomic() || in_interrupt()) {
+        DBGLOG(HAL, WARN, "MMIO failure in atomic context - scheduling recovery\n");
+        mt7902_schedule_recovery_from_atomic(prAdapter->prGlueInfo);
+        return WLAN_STATUS_PENDING;
+    }
+    
+    /* Process context - safe to call directly */
+    return mt79xx_pci_function_recover(
+        prAdapter->prGlueInfo->rHifInfo.pdev,
+        prAdapter->prGlueInfo);
 }


TESTING AFTER APPLYING:
========================

1. Compile the driver with the changes
2. Load the driver: insmod mt7902.ko
3. Test normal operation: connect to WiFi, transfer data
4. Trigger the bug: sudo setpci -s XX:XX.X COMMAND=0x0
5. Check dmesg:
   - Should see "MMIO failure detected in atomic context"
   - Should see "Recovery work starting (process context)"
   - Should NOT see "BUG: scheduling while atomic"
   - Should see either success or failure message
6. Device should recover (or fail cleanly without kernel panic)
