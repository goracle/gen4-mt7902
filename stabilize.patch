--- a/os/linux/hif/pcie/pcie.c
+++ b/os/linux/hif/pcie/pcie.c
@@ -280,6 +280,12 @@
 	mutex_unlock(&prHifInfo->recovery_lock);
 }
 
+static int mt7902_mmio_dead(struct GL_HIF_INFO *prHifInfo) {
+	u32 val;
+	pci_read_config_dword(prHifInfo->pdev, 0, &val);
+	return (val == 0xffffffff);
+}
+
 void mt7902_schedule_recovery_from_atomic(struct GLUE_INFO *prGlueInfo)
 {
 	struct GL_HIF_INFO *prHifInfo = &prGlueInfo->rHifInfo;
@@ -293,12 +299,20 @@
 static irqreturn_t mtk_pci_interrupt(int irq, void *dev_instance)
 {
 	struct GLUE_INFO *prGlueInfo = NULL;
+	struct GL_HIF_INFO *prHifInfo;
 
 	prGlueInfo = (struct GLUE_INFO *) dev_instance;
 	if (!prGlueInfo) {
 		DBGLOG(HAL, INFO, "No glue info in mtk_pci_interrupt()\n");
 		return IRQ_NONE;
 	}
+	prHifInfo = &prGlueInfo->rHifInfo;
+
+	if (mt7902_mmio_dead(prHifInfo)) {
+		disable_irq_nosync(irq);
+		mt7902_schedule_recovery_from_atomic(prGlueInfo);
+		return IRQ_HANDLED;
+	}
 
 	halDisableInterrupt(prGlueInfo->prAdapter);
